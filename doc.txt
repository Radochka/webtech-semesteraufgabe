allgemein:
cls - terminal leeren
ctrl+alt+l - formatiert file
alt+enter - vorschläge zum import etc

3.5 - Passport
    -> npm i passport passport-jwt // jede Route wird geschützt von unauthorized User
    -> passport.js wird in einem Ordner middleware erstellt

Doc_Backend:
4.1 - API (getPositionByCategoryID - controller.postion.js)
    -> app.js - wir erschliessen eine route
    -> routes.name.js - wir legen die funktionen fest, die unter best. router aufzurufen.
    -> controller.name.js - wir beschreiben die funktionen, die in router.name.js aufgerufen werden
4.2 - API (createPosition, removePosition, updatePosition - controller.postion.js)
    -> app.js - wir erschliessen eine route
    -> routes.name.js - wir legen die funktionen fest, die unter best. router aufzurufen.
    -> controller.name.js - wir beschreiben die funktionen, die in router.name.js aufgerufen werden

4.3 - API (getAll, getById, remove - controller.category.js)
    -> app.js - wir erschliessen eine route
    -> routes.name.js - wir legen die funktionen fest, die unter best. router aufzurufen.
    -> controller.name.js - wir beschreiben die funktionen, die in router.name.js aufgerufen werden

4.4 - API (upload.js, updateCategory - controller.category.js)
    -> middleware - upload.js - konfiguration wie und wohin wird file gespeichert
    -> multer, erlaubt das Hochladen des Files
    -> moment,
    -> funktion multer() - const storage, fileFilter, limits festlegen
    -> uploads (ordner) - hier werden files gespeichert

4.5 - API (createCategory, updateCategory - controller.category.js)
    -> router.category.js - upload.single('image') einschliessen (single heißt, dass nur ein file wird hochgeladen)
    -> app.js - app.use('/uploads', express.static('uploads')), um den file auf der Seite hochzuladen

4.6 - (getAll, createOrder - controller.order.js)
    -> app.js - wir erschliessen eine route
    -> routes.name.js - wir legen die funktionen fest, die unter best. router aufzurufen.
    -> controller.name.js - wir beschreiben die funktionen, die in router.name.js aufgerufen werden



Doc_Frontend:
5.1 - Einstellungen für Angular: Angular anlegen
	-> npm i -g @angular/cli@latest //wird global installiert,egal aus welchem ordner man macht
	-> cd Projekt-Name
	-> ng new <directoryname>
	-> cd <directoryname>
	-> ncu -u
	-> npm i
	-> ng serve - NG-Server starten

5.2 - Einstellungen für Angular: Start
    -> Im package.json (aus backend) änderungen vornehmen, um back- und frontend gleichzeitig zu starten
	-> im scripts: {
		hinzufügen
		client-install: npm install --prefix client,
		client: npm run start --prefix client,
		dev: "concurrently \"npm run server\" \"npm run client\""
    }
    -> npm i -D concurrently - um frontend und backend gleichzeitig zu starten (-D intall des package als Development)
	-> npm run dev - um front- und backend zu starten

5.3 - Einstellungen für Angular: Styles
    -> im Ordner src in styles.css -> @import "theme/styles.min.css" (sind unsere styles für Webanwendung)
    -> cd <frontendordner>
    -> npm i materialize-css@next
    -> im Ordner src in styles.css -> @import "~materialize-css/dist/css/materialize.min.css" (sind unsere styles für Webanwendung)
    -> im Ordner src in main.css -> import 'materialize-css/dist/js/materialize'
    -> im FrontendOrdner angular.json -> im styles sind unsere src/styles.css angeschlossen und dort sind usere styles importiert

5.4 - Einstellungen für Angular Proxy
    -> proxy ist dafür da, um an einem Platz die URL-adresse festzulegen. Wenn im Backend die Adresse sich ändert,
       müssen wir diese nicht überall im frontend ändern.
    -> neue file im frontendOrdner proxy.conf.json
        {
          "/api/*": { (für alle requests, die mit api anfangen
            "target": "http://localhost:5000", (ziel)
            "secure": false,
            "logLevel": "debug",
            "changeOrigin": true
          },
          "/uploads/*": { (für alle requests, die für die fotos und files
            "target": "http://localhost:5000",
            "secure": false,
            "logLevel": "debug",
            "changeOrigin": true
          }
        }
    -> im frontend/package.json ergänzen im "start": "ng serve --proxy-config proxy.conf.json", damit bei dem Start
       die URLadresse abgefragt wird

5.5 - Routing Angular - app-routing.module.ts
    -> alle neuen componente werden automatisch ins app.module.ts deklariert
    -> alle neuen module werden automatisch ins app.module.ts importiert
    -> alle routes werden im app-routing.module.ts registiert
       const routes: Routes = [
         {
           path: 'login', component: LoginPageComponent (diese Rout ist nur zum Testen
         }
       ];
    -> app.component.html wir schliessen router-outlet, der alle seite anschliesst

5.6 - Layout Logins/Registration
    -> wir erzeugen zwei layouts ng g c shared/layouts/site-layout und auth-layout
    -> wir registirieren die beiden layouts in app-routing.module.js bei routes
        diese routes haben dann auch kinder
        const routes: Routes = [
          {
              path: '', component: AuthLayoutComponent, children: [
                {path: '', redirectTo: '/login', pathMatch: 'full'},
                {path: 'login', component: LoginPageComponent},
                {path: 'register', component: RegisterPageComponent}
              ]
            },
            {
              path: '', component: SiteLayoutComponent, children: [

              ]
            }
        ];
    -> in auth-layout.component.html - nav und app-root

5.7 Login-page
    -> gesamte div auf form ändern (form - formulare in angular)
    -> button ergänzen attribut: type="submit" - erlaubt mit enter knopf zu drucken,
       [disabled]="form.invalid" = blockiert den knopt, wenn die eingaben nicht korrekt sind
    -> form ergänzen attribute: [formGroup]="form" - variable, (ngSubmit)="onSubmit()" - listener
    -> variable "form" erzeugen
    -> ngOnInit() beschreiben, FormControl kontrolliert ob die bedingungen bei der Eingabe in Formular stimmen
    -> [disabled]="form.invalid" wenn form nicht valid, die felder sind nicht richtig ausgefüllt

    -> span für email-feld festlegen mit bedingungen -*ngIf="form.get('email').invalid && form.get('email').touched"
       <span *ngIf="form.get('email').errors['required']">Email darf nicht leer sein</span>
       <span *ngIf="form.get('email').errors['email']">Email ist nicht korrekt</span>
       [ngClass]="{'invalid': form.get('email').invalid && form.get('email').touched}" - ändert sich Email-feld sein Aussehen
    -> span für password-feld festlegen mit bedingungen - so wie bei email

5.8 - Sevice für Angular
    -> in SharedOrdner erstelllen sevicesOrdner, in dem auth.service.ts
    -> interface.ts für jedes Model
    -> wir schreiben zwei funktionen login(user: User) und register()
    -> im contructor schalten wir private http: HttpClient ein
    -> ins app.module.ts importieren wir HttpClientModul
    -> ins login-page.component.ts schalten wir ins construktor(private auth: AuthService) ein
    -> ins login-page.component.ts schreiben wir variable aSub-Subscription, um die verlust der Informationen
    nach der Login zu vermeiden.
    -> ins login-page.component.ts schreiben wir funktion ngOnDestroy(), um von der subscribe zu entschreiben
    отписаться от прослушки
    -> ins auth.servive ins login() ergänzen wir mit token, setToken() und getToken()
    -> ins auth.service isAuthentification(), cancel()


5.9 - Registration
    -> so wie bei der login
    -> noch mal anschauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

5.10 - Schutz für die Routes - Guard
    -> hier schreiben wir zwei funktionen canActivate() und canActivateChild()
    -> canActivate() - wenn true, dann können wir sehen diese Seite
    -> canActivateChild() - die gleiche für Children

5.11 - Token interceptor (hört die http-require und ändert sie) um zu jeder Anfrage auf die api Token zu hinzufügen
    -> token.interceptor.ts
    -> falls isAuthentification true, wird die http-req Token hinzugefügt
    -> interceptor soll ins app.module registriert werden unter providers:[{provide: HTTP_INTERCEPTORS;
    multi: true, useClass: TokenInterceptor}]
    -> um bei dem Restart der Seite Token nicht verloren gegangen ist, schreien wir ins app.component ngOnInit()

5.12 - Fehler bei der Anmeldung und Registrierung
    -> es wird im classesOrdner einen material.service.ts erstellt
    -> es wird von Materializecss einen toats() benutzt
    -> in onSubmit() wird für die Fehler MaterialService.toast(error.error.message) eingefügt
    -> in ngOnInit() wird Test für die Fehler erstellt MaterialService.toast('Jetzt können Sie sich noch einmal einloggen')

5.13 - Fehler 401 - wenn token ausgelaufen ist
    -> noch mal anschauen!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


6.1 - Layout Site
    -> alles vorbereiten
    -> navigation als for-schleife definieren
    -> add - icons (material-icons) wird angeschlossen materializecss.com. Kopieren link bei der HTTL Setups (google icons)
    -> fügen zu idex.html (9 zeile)
    -> logout definieren
    -> materializecss.com - floating action button - in classOrdner - static initializeFloatingButton()
    ->

6.2 - restilche Components generieren
    -> die runde Knopfe rechts unten navigieren

6.3 - Site Categories + loader(zeigt, dass die seite geladen wird)
    -> categories.html
    -> interface - backend-model category duplizieren user?: string (? heißt nicht notwendig oder muss nicht aufgefüllt sein)
    -> categories.service.ts - getAll(), um alle categories auf die seite bekommen
       (return ist in dem fall stream, um stream rauszugeben brauchen wir observable)
    -> im categories-page.ts - ngOnInit(): this.categoriesService.fetch()
    -> materialize - preloader - rundes ding, der zeigt, dass etwas geladen wird, während user wartet
       dafür ng g c shared/components/loader
    -> integrieren ins categories

6.4 - Flow - dh wir haben die category seite formatiert
    -> bis die daten aus db hochgeladen sind, wird loader angezeigt.
    -> falls es noch keine categories gibt, wird text angezeigt
    -> schließen den link auf einzelnen positionen ([routerLink]="['/categories', category._id]")

6.5 - Categorien hinzufügen
    -> wir erstellen ng g c category-page/categories-form
    -> ins app-routing registrieren die route:
        {path: 'categories/new', component: CategoriesFormComponent}, - für new category
        {path: 'categories/:id', component: CategoriesFormComponent}, - fürs update der category
    -> festgelegt, ob wir category neu oder redaktieren mit Hilfe von isNew

6.6 - Categories new und update
    -> [disabled]="form.invalid || form.disabled" blockiert button, wenn server probleme hat
    -> falls update, daten der category müssen angezeigt sein -> categories.service.ts schreiben getById()
    -> getById() anbinden an category-form.component.ts

6.7 - Upload Bilder
    -> vor den button <input type="file" class="dn" #input> einfügen
    -> button - class="nd" - nonedisplay
    -> button - Methode schreiben triggerClick() (click auf button, kommt fenster zum foto auswählen)





